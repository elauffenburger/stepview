{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n    BgChangeSegment,\r\n    BpmSegment,\r\n    HeaderSegment,\r\n    Note,\r\n    NoteMeasureData,\r\n    StopSegment,\r\n    StepChart,\r\n    NotesSegment,\r\n    BEATS_PER_MEASURE,\r\n    NoteType,\r\n    NoteData,\r\n    ArrowType,\r\n    ArrowDirection\r\n} from '../../../models';\r\nimport { split, clampPrecision } from '../../../helpers';\r\n\r\nimport _ from 'lodash';\r\nimport { AbstractStepChartParser } from '../abstract-parser';\r\n\r\nexport class SmFileStepChartParser extends AbstractStepChartParser {\r\n    protected doParse(file: string): StepChart {\r\n        // Group lines by segment\r\n        const segments = this.splitFileIntoSegments(file);\r\n\r\n        // Validate file segments\r\n        this.validateSegments(segments);\r\n\r\n        // Get header info from header segment\r\n        const header = this.parseHeaderSegment(segments[0]);\r\n\r\n        // Build the notes segments (all the following segments should be notes segments)\r\n        const notesSegments = this.parseNotesSegments(segments.slice(1));\r\n\r\n        // Build the stepchart!\r\n        return {\r\n            headerSegment: header,\r\n            noteSegments: notesSegments\r\n        }\r\n    }\r\n\r\n    splitFileIntoSegments(file: string) {\r\n        // Split the file into its constituent lines\r\n        const lines = file.split(/\\r*\\n/);\r\n\r\n        // Each file segment is delimited with an empty line\r\n        return split(lines, line => line == '');\r\n    }\r\n\r\n    validateSegments(segments: string[][]): { result: boolean, errors: string[] } {\r\n        if (!segments) {\r\n            return { result: false, errors: [\"'segments' was null or empty!\"] };\r\n        }\r\n\r\n        if (segments.length == 1) {\r\n            return { result: false, errors: [`Only one Segment was found, which indicates 0 step patterns!`] }\r\n        }\r\n\r\n        return { result: true, errors: [] };\r\n    }\r\n\r\n    parseHeaderSegment(lines: string[]): HeaderSegment {\r\n        const result: HeaderSegment = {};\r\n\r\n        let i = 0;\r\n        while (i < lines.length) {\r\n            let builtLine = '';\r\n\r\n            // Consolidate multi-line statements into a single line\r\n            do {\r\n                const currentLine = lines[i++].trim();\r\n                const sanitizedLine = this.stripCommentsFromLine(currentLine);\r\n\r\n                builtLine += sanitizedLine;\r\n            }\r\n            // Keep looping while there are still lines to read\r\n            //   and either: \r\n            //      the line still doesn't have any content\r\n            //      or the line does have content but it's still not ';'\r\n            while (i < lines.length && (builtLine.length == 0 || builtLine[builtLine.length - 1] != ';'))\r\n\r\n            const { tag, value } = this.parseHeaderLine(builtLine);\r\n\r\n            switch (tag) {\r\n                case 'TITLE':\r\n                    result.title = value;\r\n                    break;\r\n                case 'SUBTITLE':\r\n                    result.subtitle = value;\r\n                    break;\r\n                case 'ARTIST':\r\n                    result.artist = value;\r\n                    break;\r\n                case 'TITLETRANSLIT':\r\n                    result.titleTransliteration = value;\r\n                    break;\r\n                case 'SUBTITLETRANSLIT':\r\n                    result.subtitleTransliteration = value;\r\n                    break;\r\n                case 'ARTISTTRANSLIT':\r\n                    result.artistTransliteration = value;\r\n                    break;\r\n                case 'CREDIT':\r\n                    result.credit = value;\r\n                    break;\r\n                case 'BANNER':\r\n                    result.bannerFileName = value;\r\n                    break;\r\n                case 'BACKGROUND':\r\n                    result.backgroundFileName = value;\r\n                    break;\r\n                case 'CDTITLE':\r\n                    result.cdTitle = value;\r\n                    break;\r\n                case 'MUSIC':\r\n                    result.musicFileName = value;\r\n                    break;\r\n                case 'OFFSET':\r\n                    result.offset = parseFloat(value);\r\n                    break;\r\n                case 'SAMPLESTART':\r\n                    result.sampleStart = parseFloat(value);\r\n                    break;\r\n                case 'SAMPLELENGTH':\r\n                    result.sampleLength = parseFloat(value);\r\n                    break;\r\n                case 'SELECTABLE':\r\n                    result.selectable = value == 'YES';\r\n                    break;\r\n                case 'BPMS':\r\n                    result.bpmSegments = this.parseBpmSegments(value);\r\n                    break;\r\n                case 'DISPLAYBPM':\r\n                    result.displayBpm = value == '*' ? '*' : parseFloat(value);\r\n                    break;\r\n                case 'STOPS':\r\n                    result.stopSegments = this.parseStopSegments(value);\r\n                    break;\r\n                case 'BGCHANGES':\r\n                    result.bgChangeSegments = this.parseBgChangeSegments(value);\r\n                    break;\r\n                default:\r\n                // Here's where I'd put my logging...IF I HAD ANY\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    stripCommentsFromLine(line: string): string {\r\n        const firstCommentIndex = line.indexOf('//');\r\n\r\n        // If we didn't find a comment, just return the line;\r\n        // otherwise, ignore everything after the comment\r\n        return firstCommentIndex == -1\r\n            ? line\r\n            : line.substring(0, firstCommentIndex - 1);\r\n    }\r\n\r\n    parseHeaderLine(line: string): { tag: string, value: string } {\r\n        if (!line || !line.length || line[0] != '#') {\r\n            return { tag: '', value: '' };\r\n        }\r\n\r\n        const tagValueSeparator = line.indexOf(':');\r\n\r\n        const tag = line.substring(1, tagValueSeparator);\r\n        const value = line.substring(tagValueSeparator + 1, line.lastIndexOf(';'));\r\n\r\n        return { tag, value };\r\n    }\r\n\r\n    parseBpmSegments(value: string): BpmSegment[] {\r\n        return this.fromTagListValueToKvpList(value)\r\n            .map(kvp => {\r\n                return <BpmSegment>{\r\n                    beat: parseInt(kvp[0]),\r\n                    bpm: parseFloat(kvp[1])\r\n                };\r\n            });\r\n    }\r\n\r\n    parseStopSegments(value: string): StopSegment[] {\r\n        return this.fromTagListValueToKvpList(value)\r\n            .map(kvp => {\r\n                return <StopSegment>{\r\n                    beat: parseInt(kvp[0]),\r\n                    duration: parseFloat(kvp[0])\r\n                }\r\n            });\r\n    }\r\n\r\n    parseBgChangeSegments(value: string): BgChangeSegment[] {\r\n        return this.fromTagListValueToKvpList(value)\r\n            .map(kvp => {\r\n                return <BgChangeSegment>{\r\n                    beat: parseInt(kvp[0]),\r\n                    name: kvp[1]\r\n                };\r\n            });\r\n    }\r\n\r\n    fromTagListValueToKvpList(value: string): string[][] {\r\n        return !value ? [] : value.split(',').map(segment => {\r\n            const keyValueSeparatorIndex = segment.indexOf('=');\r\n\r\n            const left = segment.substring(0, keyValueSeparatorIndex);\r\n            const right = segment.slice(keyValueSeparatorIndex + 1);\r\n\r\n            // So, it appears over time the standard \"key=value\" spec is no longer\r\n            // valid due to extensions; as in: a value may now contain '=' characters \r\n            // for additional metadata that is meaningful only to the \r\n            // feature receiving the value\r\n            return [left, right];\r\n        });\r\n    }\r\n\r\n    parseNotesSegments(segments: string[][]): NotesSegment[] {\r\n        // We need to sanitize the segments ahead of time to ensure we\r\n        // don't try to parse zero-length \"segments\"\r\n        return segments.map(segment => this.sanitizeNotesSegmentLines(segment))\r\n            .filter(segment => segment.length)\r\n            .map(segment => this.parseNotesSegment(segment));\r\n    }\r\n\r\n    parseNotesSegment(lines: string[]): NotesSegment {\r\n        if (!lines || !lines.length) {\r\n            // TODO: error\r\n        }\r\n\r\n        // Sanitize the segment\r\n        const sanitizedLines = this.sanitizeNotesSegmentLines(lines);\r\n\r\n        // Parse the first line to ensure this is actually a notes segment\r\n        const { tag } = this.parseHeaderLine(sanitizedLines[0]);\r\n        if (tag != 'NOTES') {\r\n            // TODO: error\r\n        }\r\n\r\n        // Get the header data out of the textual data\r\n        const headerData = sanitizedLines.slice(1, 6)\r\n            .reduce((acc, line, i) => {\r\n                const { value } = this.parseNotesSegmentHeaderLine(line);\r\n\r\n                switch (i) {\r\n                    case 0:\r\n                        acc.type = <any>value.toLowerCase();\r\n                        break;\r\n                    case 1:\r\n                        acc.description = value;\r\n                        break;\r\n                    case 2:\r\n                        acc.difficultyClass = <any>value.toLowerCase();\r\n                        break;\r\n                    case 3:\r\n                        acc.difficultyMeter = parseInt(value);\r\n                        break;\r\n                    case 4:\r\n                        const values = value.split(',');\r\n\r\n                        acc.radarValues = {\r\n                            voltage: parseFloat(values[0]),\r\n                            stream: parseFloat(values[1]),\r\n                            chaos: parseFloat(values[2]),\r\n                            freeze: parseFloat(values[3]),\r\n                            air: parseFloat(values[4])\r\n                        };\r\n\r\n                        break;\r\n                }\r\n\r\n                return acc;\r\n            }, <NotesSegment>{});\r\n\r\n        // All measure line groups:\r\n        // ex: 1001\\n1001,\\n1001,\\n -> [['1001', '1001'], ['1001']]\r\n        const measures = split(sanitizedLines.slice(6), line => line == ',');\r\n\r\n        let beatNum = 0;\r\n        const notes = measures.map((measureNotes, measureNum) => {\r\n            const sanitizedMeasureNotes = measureNotes\r\n                .filter(line => {\r\n                    // If this is the end of a measure, ignore the line\r\n                    return line != ';';\r\n                });\r\n\r\n            const numNotesInMeasure = sanitizedMeasureNotes.length;\r\n\r\n            // We want to know how many beats each note takes for beat num and note type calculations\r\n            const beatsPerNote = clampPrecision(BEATS_PER_MEASURE / sanitizedMeasureNotes.length);\r\n\r\n            return <NoteMeasureData>{\r\n                measure: measureNum,\r\n                notes: sanitizedMeasureNotes.reduce((notes, line, noteNum) => {\r\n                    const noteData: NoteData = {\r\n                        arrows: {\r\n                            left: { direction: ArrowDirection.Left, type: this.getArrowTypeAt(0, line) },\r\n                            down: { direction: ArrowDirection.Down, type: this.getArrowTypeAt(1, line) },\r\n                            up: { direction: ArrowDirection.Up, type: this.getArrowTypeAt(2, line) },\r\n                            right: { direction: ArrowDirection.Right, type: this.getArrowTypeAt(3, line) },\r\n                        }\r\n                    };\r\n\r\n                    const note: Note = {\r\n                        beat: beatNum,\r\n                        rawData: line,\r\n                        type: this.getNoteType(noteNum, numNotesInMeasure),\r\n                        data: noteData\r\n                    };\r\n\r\n                    // We need to calculate the beat the NEXT note will be on\r\n                    beatNum += beatsPerNote;\r\n\r\n                    notes.push(note);\r\n\r\n                    return notes;\r\n                }, <Note[]>[])\r\n            };\r\n        });\r\n\r\n        return {\r\n            ...headerData,\r\n            measures: notes\r\n        };\r\n    }\r\n\r\n    private getNoteType(noteNum: number, numNotesInMeasure: number): NoteType {\r\n        const percentageOfMeasure = noteNum / numNotesInMeasure;\r\n\r\n        // Find the first type of note for which percentageOfMeasure % type == 0\r\n        const type = _.find(Object.keys(NoteType), t => percentageOfMeasure % <number><any>t == 0);\r\n\r\n        // Parse the type as a number if we found it or default to 192nd notes\r\n        return (type && parseFloat(type)) || NoteType.ONE_NINETY_SECOND;\r\n    }\r\n\r\n    private sanitizeNotesSegmentLines(lines: string[]) {\r\n        return lines\r\n            .map(this.stripCommentsFromLine)\r\n            .map(line => line.trim())\r\n            .filter(line => line != '');\r\n    }\r\n\r\n    parseNotesSegmentHeaderLine(line: string): { value: string } {\r\n        if (!line) {\r\n            return { value: '' };\r\n        }\r\n\r\n        const parts = line.split(':');\r\n        if (!parts.length) {\r\n            return { value: '' };\r\n        }\r\n\r\n        return { value: parts[0] };\r\n    }\r\n\r\n    private getArrowTypeAt(position: number, rawData: string): ArrowType {\r\n        const typeCode = rawData[position];\r\n\r\n        switch(typeCode) {\r\n            case '0':\r\n                return ArrowType.None;\r\n            case '1':\r\n                return ArrowType.Normal;\r\n            case '2':\r\n                return ArrowType.HoldHead;\r\n            case '3':\r\n                return ArrowType.HoldRollTail;\r\n            case '4':\r\n                return ArrowType.RollHead;\r\n            case 'M':\r\n                return ArrowType.Mine;\r\n        }\r\n\r\n        return ArrowType.Unknown;\r\n    }\r\n}"],"sourceRoot":""}