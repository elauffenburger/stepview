{"version":3,"sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Arrow, NoteDataArrows, StepChart, NotesSegment, LINES_PER_MEASURE, makeEmptyNote, ArrowType, Note, NoteMeasureData, NoteType, BEATS_PER_MEASURE } from \"../../../models\";\r\nimport { StepChartParser } from \"..\";\r\nimport * as _ from \"lodash\";\r\nimport { clampPrecision } from \"../../../helpers\";\r\n\r\nexport type NoteArrowAccessor = (arrows: NoteDataArrows) => Arrow;\r\n\r\nexport abstract class AbstractStepChartParser implements StepChartParser {\r\n    constructor(private args: { normalizeChart: boolean }) { }\r\n\r\n    protected abstract doParse(file: string): StepChart;\r\n\r\n    parse(file: string): StepChart {\r\n        const parsedChart = this.doParse(file);\r\n\r\n        // If we're not supposed to normalize, bail\r\n        if (!this.args.normalizeChart) {\r\n            return parsedChart;\r\n        }\r\n\r\n        // Otherwise: normalize\r\n        for (let noteSegment of parsedChart.noteSegments) {\r\n            const noteArrowAccessors: NoteArrowAccessor[] = [\r\n                arrows => arrows.left,\r\n                arrows => arrows.down,\r\n                arrows => arrows.up,\r\n                arrows => arrows.right,\r\n            ];\r\n\r\n            const normalizedMeasures = this.normalizeMeasuresInNoteSegment(noteSegment, noteArrowAccessors);\r\n            noteSegment.measures = normalizedMeasures;\r\n        }\r\n\r\n        return parsedChart;\r\n    }\r\n\r\n    protected normalizeMeasuresInNoteSegment(noteSegment: NotesSegment, noteArrowAccessors: NoteArrowAccessor[]) {\r\n        let noteNum = 0;\r\n        return noteSegment.measures\r\n            .reduce((measures, measure) => {\r\n                const numNotes = measure.notes.length;\r\n                const linesToSkipPerNote = LINES_PER_MEASURE / numNotes - 1;\r\n\r\n                const notes = measure.notes.reduce((acc, note) => {\r\n                    const noteArrows = note.data.arrows;\r\n\r\n                    acc.push(note);\r\n                    noteNum++\r\n\r\n                    // We need to map our \"explicitly defined lines\" space to the \"total lines per beat\" space\r\n                    // e.g. map 4 lines -> 48 notes\r\n                    for (let skippedLine = 0; skippedLine < linesToSkipPerNote; skippedLine++) {\r\n                        if (acc.length >= LINES_PER_MEASURE) {\r\n                            break;\r\n                        }\r\n\r\n                        const fillerNote: Note = {\r\n                            ...makeEmptyNote(),\r\n                            beat: clampPrecision(noteNum * 4 * NoteType.FORTY_EIGHTH)\r\n                        };\r\n\r\n                        let fillerNoteArrows = fillerNote.data.arrows;\r\n\r\n                        // Use our note accessors to perform transforms on our filler notes\r\n                        for (let noteArrowAccessor of noteArrowAccessors) {\r\n\r\n                            // Use the accessor to get the explicitly defined note\r\n                            const noteArrow = noteArrowAccessor(noteArrows);\r\n\r\n                            // Use the accessor to get the filler note\r\n                            const fillerNoteArrow = noteArrowAccessor(fillerNoteArrows);\r\n\r\n                            // Mark notes between HoldHead and HoldRollTail as Hold\r\n                            if (this.isHold(noteArrow)) {\r\n                                fillerNoteArrow.direction = noteArrow.direction;\r\n                                fillerNoteArrow.type = ArrowType.Hold;\r\n                            }\r\n                        }\r\n\r\n                        acc.push(fillerNote);\r\n                        noteNum++;\r\n                    }\r\n\r\n                    return acc;\r\n                }, <Note[]>[]);\r\n\r\n                return _.concat(measures, {\r\n                    ...measure,\r\n                    notes: notes\r\n                });\r\n            }, <NoteMeasureData[]>[]);\r\n    }\r\n\r\n    protected isHold(arrow: Arrow): boolean {\r\n        return arrow.type == ArrowType.HoldHead;\r\n    }\r\n}"],"sourceRoot":""}